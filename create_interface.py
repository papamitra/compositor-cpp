#!/usr/bin/env pytnon3

import xml.etree.ElementTree as etree
import sys

exclude_interface = ["wl_registry", "wl_resource"]

header_preamble = """// Generated by create_interface.py
#pragma once

#include <wayland-server.h>

#include "resource.h"
#include "client.h"
#include "display.h"

namespace karuta {{
{interfaces}
}}
"""

source_preamble = """// Generated by create_interface.py
#include "server-protocol.h"

namespace karuta {{
{interface_instance}
}}
"""

class_format = """
class {classname}Interface : public ImplInterface {{
private:
{member_funcs}
public:
{static_funcs}
{get_implementation}
}};
"""

def usage():
    print("""
usage: create_interface.py input_file [output_file]
""")

type_map = {
    "uint": "uint32_t",
    "string": "const char *",
    "fd": "int32_t",
    "int": "int32_t",
    "new_id": "uint32_t"
}

acceptable_interface = ["wl_client", "wl_resource"]

def to_c_type(arg):
    t = type_map.get(arg.attrib['type'], None)
    if t: return t
    if (arg.attrib['type'] == 'object'):
        if arg.attrib['interface'] not in acceptable_interface:
            return 'struct wl_resource *'
        return 'struct ' + arg.attrib['interface'] + ' *'

def to_cpp_type(arg):
    t = type_map.get(arg.attrib['type'], None)
    if t: return t
    if (arg.attrib['type'] == 'object'):
        if arg.attrib['interface'] not in acceptable_interface:
            return 'struct wl_resource *'

        return 'class ' + to_class_name(arg.attrib['interface']) + '*'

def to_class_name(name):
    name = name.replace('wl_', '')
    return ''.join(map(lambda s: s.title(), name.split('_')))

def to_member_funcs(reqs):
    s = ""
    for (name, args) in reqs:
        s += '\n'
        s += to_member_func(name, args)
    return s

def to_member_func(name, args):
    s = '    virtual void ' + name + '('
    s += '\n        Client& client'
    s += ',\n        Resource& resource'
    for arg in args:
        s += ',\n        ' + to_cpp_type(arg) + ' ' + arg.attrib['name']
    s += ') = 0;\n'
    return s

def to_static_funcs(ifname, reqs):
    s = ""
    for (name, args) in reqs:
        s += '\n'
        s += to_static_func(ifname, name, args)
    return s

def to_static_func(ifname, name, args):
    classname = to_class_name(ifname) + 'Interface'
    s = '    static void ' + name + '_('
    s += '\n        struct wl_client* client'
    s += ',\n        struct wl_resource* resource'
    for arg in args:
        s += ',\n        ' + to_c_type(arg) + ' ' + arg.attrib['name']
    s += ') {'
    s += '\n            auto p = static_cast<{classname}*>(wl_resource_get_user_data(resource));'.format(classname=classname)
    s += '\n            Client c(client); Resource r(resource);'
    s += '\n            p->{func_name}(c, r'.format(func_name=name)
    for arg in args:
        s += ', ' + arg.attrib['name']
    s += ');'
    s += '\n    }\n'
    return s

def parse_request(req):
    name = req.attrib['name']
    args = []
    for child in req:
        if child.tag == 'arg':
            args.append(child)
    return (name, args)

def parse_interface(intf):
    name = intf.attrib['name']
    reqs = []
    for child in intf:
        if child.tag == 'request':
            reqs.append(parse_request(child))
    return (name, reqs)

def create_interface_instance(name, reqs):
    if len(reqs) == 0: return ""
    s = 'struct {ifname}_interface {ifname}_interface_instance = {{'.format(ifname=name)
    for (funcname, args) in reqs:
        s += '\n    &{classname}Interface::{funcname}_,'.format(classname=to_class_name(name), funcname=funcname)
    s += '\n};'
    return s

def to_get_impl(name):
    return """\
    void* get_interface() override {{
        extern struct {name}_interface {name}_interface_instance;
        return static_cast<void*>(&{name}_interface_instance);
    }}""".format(name=name)

def create_interface(intf):
    (name, reqs) = intf
    s = ""
    s += class_format.format(classname=to_class_name(name),
                             member_funcs=to_member_funcs(reqs),
                             static_funcs=to_static_funcs(name, reqs),
                             get_implementation="" if len(reqs) == 0 else to_get_impl(name)
    )
    return s

def main():
    if len(sys.argv) < 3:
        usage()
        sys.exit(1)

    header_file = open(sys.argv[2] + '.h', 'w')
    source_file = open(sys.argv[2] + '.cpp', 'w')

    tree = etree.parse(sys.argv[1])
    root = tree.getroot()
    header_str = ""
    source_str = ""
    for child in root:
        if child.tag == 'interface' and child.attrib['name'] not in exclude_interface:
            interface = parse_interface(child)
            header_str += '\n' + create_interface(interface)
            source_str += '\n' + create_interface_instance(*interface)

    print(header_preamble.format(interfaces=header_str), file=header_file)

    print(source_preamble.format(interface_instance=source_str), file=source_file)

if __name__ == '__main__':
    main()
