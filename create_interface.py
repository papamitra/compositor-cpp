#!/usr/bin/env pytnon3

import xml.etree.ElementTree as etree
import sys
import re

exclude_interface = ["wl_registry", "wl_resource"]

header_preamble = """// Generated by create_interface.py
#pragma once

#include <wayland-server.h>

#include "client.h"
#include "resource.h"
#include "impl_interface.h"
"""

header_body = """
namespace karuta {{
namespace {namespace} {{
{interface_define}
}}
}}
"""

source_preamble = """// Generated by create_interface.py
#include "server-protocol.h"
"""

source_body = """
namespace karuta {{
namespace {namespace} {{
{interface_instance}
}}
}}
"""

class_format = """
class {classname}Interface : public karuta::ImplInterface {{
private:
{member_funcs}
public:
{static_funcs}
{get_interface}
{get_wl_interface}
{version}
}};
"""

static_function = """
    static void {reqname}_(
        struct wl_client* client,
        struct wl_resource* resource{args}) {{

        Client client_(client);
        Resource resource_(resource);{to_class}

        auto p = static_cast<{classname}*>(wl_resource_get_user_data(resource));
        p->{reqname}(client_, resource_ {call_args});
    }}"""

def usage():
    print("""
usage: create_interface.py input_file [output_prefix]
""")

type_map = {
    "uint": "uint32_t",
    "string": "const char *",
    "fd": "int32_t",
    "int": "int32_t",
    "new_id": "uint32_t"
}

acceptable_interface = ["wl_client", "wl_resource"]

def to_c_type(arg):
    t = type_map.get(arg.attrib['type'], None)
    if t: return t
    if (arg.attrib['type'] == 'object'):
        if arg.attrib['interface'] not in acceptable_interface:
            return 'struct wl_resource *'
        return 'struct ' + arg.attrib['interface'] + ' *'

def to_cpp_type(arg):
    t = type_map.get(arg.attrib['type'], None)
    if t: return t
    if (arg.attrib['type'] == 'object'):
        (ns, cname) = to_ns_and_class(arg.attrib['interface'])
        return 'class {ns}::{cname}*'.format(ns=ns, cname=cname)

def to_ns_and_class(name):
    splitted = name.split('_')
    return (splitted[0], ''.join(map(lambda s: s.title(), splitted[1:])))

def to_class_name(name):
    return to_ns_and_class(name)[1]

def to_member_funcs(reqs):
    s = ""
    for (name, args) in reqs:
        s += '\n'
        s += to_member_func(name, args)
    return s

def to_member_func(name, args):
    s = '    virtual void ' + name + '(Client& client, Resource& resource'
    args_str = ',\n'.join(map(lambda arg: '        ' + to_cpp_type(arg) + ' ' + arg.attrib['name'], args))
    s += '' if args_str == '' else ',\n' + args_str
    s += ') = 0;\n'
    return s

def to_static_funcs(ifname, reqs):
    s = ""
    for (name, args) in reqs:
        s += '\n'
        s += to_static_func(ifname, name, args)
    return s

def to_static_func(ifname, name, args):
    classname = to_class_name(ifname) + 'Interface'

    args_str = ''.join([',\n        ' + to_c_type(arg) + ' ' + arg.attrib['name'] for arg in args])

    to_class = ''
    for arg in args:
        if arg.attrib['type'] == 'object' and arg.attrib['interface'] not in acceptable_interface:
            (ns, cname) = to_ns_and_class(arg.attrib['interface'])
            to_class += '\n        auto {name}_ = ({ns}::{cname}*)wl_resource_get_user_data((wl_resource*)({name}));'.format(ns=ns, cname=cname, name=arg.attrib['name'])

    def to_arg_name(arg):
        if arg.attrib['type'] == 'object' and arg.attrib['interface'] not in acceptable_interface:
            return arg.attrib['name'] + '_'
        else:
            return arg.attrib['name']

    call_args = ''.join([' ,' + to_arg_name(arg) for arg in args])

    return static_function.format(reqname=name,
                                  args=args_str,
                                  classname=classname,
                                  to_class=to_class,
                                  call_args=call_args)

def parse_request(req):
    name = req.attrib['name']
    args = []
    for child in req:
        if child.tag == 'arg':
            args.append(child)
    return (name, args)

def parse_interface(intf):
    name = intf.attrib['name']
    version = intf.attrib.get('version', 0)
    reqs = []
    for child in intf:
        if child.tag == 'request':
            reqs.append(parse_request(child))
    return (name, version, reqs)

def create_interface_instance(name, version, reqs):
    if len(reqs) == 0: return ""
    s = 'struct {ifname}_interface {ifname}_interface_instance = {{'.format(ifname=name)
    for (funcname, args) in reqs:
        s += '\n    &{classname}Interface::{funcname}_,'.format(classname=to_class_name(name), funcname=funcname)
    s += '\n};'
    return s

def to_get_interface(name):
    return """\
    void* get_interface() override {{
        extern struct {name}_interface {name}_interface_instance;
        return static_cast<void*>(&{name}_interface_instance);
    }}""".format(name=name)

def to_get_wl_interface(name):
    return """\
    static const struct wl_interface* get_wl_interface() {{
        extern const struct wl_interface {name}_interface;
        return &::{name}_interface;
    }}""".format(name=name)

def to_version(ver):
    return """\
    static const uint32_t version = {version};
    """.format(version=ver)

def create_interface(intf):
    (name, version, reqs) = intf
    s = ""
    s += class_format.format(classname=to_class_name(name),
                             member_funcs=to_member_funcs(reqs),
                             static_funcs=to_static_funcs(name, reqs),
                             get_interface="" if len(reqs) == 0 else to_get_interface(name),
                             get_wl_interface=to_get_wl_interface(name),
                             version=to_version(version)
    )
    return s

def create_pre_define(tree):
    from collections import defaultdict
    predefs = defaultdict(lambda: set())
    for req in tree.findall('.//request'):
        for arg in req.findall('arg'):
            if arg.attrib['type'] == 'object' and arg.attrib['name'] not in acceptable_interface:
                (ns, cname) = to_ns_and_class(arg.attrib['interface'])
                predefs[ns].add(cname)

    s = ""
    for (ns, cs) in predefs.items():
        s += '\nnamespace karuta {'
        s += '\nnamespace ' + ns + ' {'
        for c in cs:
            s += '\n    class ' + c + ';'
        s += '\n}'
        s += '\n}\n'
    return s

def main():
    if len(sys.argv) < 2:
        usage()
        sys.exit(1)

    header_file = sys.stdout if len(sys.argv) < 3 else open(sys.argv[2] + '.h', 'w')
    source_file = sys.stdout if len(sys.argv) < 3 else open(sys.argv[2] + '.cpp', 'w')

    tree = etree.parse(sys.argv[1])
    root = tree.getroot()
    header_str = ""
    source_str = ""

    print(header_preamble, file=header_file)

    print(create_pre_define(tree), file=header_file)

    for child in root:
        if child.tag == 'interface' and child.attrib['name'] not in exclude_interface:
            ns = child.attrib['name'].split('_')[0]
            interface = parse_interface(child)
            print(header_body.format(namespace=ns,
                                     interface_define=create_interface(interface)),
                  file=header_file)

    print(source_preamble, file=source_file)

    for child in root:
        if child.tag == 'interface' and child.attrib['name'] not in exclude_interface:
            ns = child.attrib['name'].split('_')[0]
            interface = parse_interface(child)

            print(source_body.format(namespace=ns,
                                     interface_instance=create_interface_instance(*interface)),
                  file=source_file)

if __name__ == '__main__':
    main()
